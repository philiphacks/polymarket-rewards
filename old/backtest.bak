// ---------- PURE DECISION FUNCTION (Step B - core EV) ----------
// Mirrors the *normal EV-based entries* logic, but PURE:
//  - no state mutation
//  - no network or file IO
// Use this in backtests by feeding snapshots from logTickSnapshot().
function decideTrade(snapshot) {
  const {
    minsLeft,
    z,
    pUp,
    pDown,
    upAsk,
    downAsk,
  } = snapshot;

  const absZ = Math.abs(z);
  const zMaxDynamic = dynamicZMax(minsLeft);

  // Same gating as live code's time/z gate
  if (
    minsLeft > 5 ||                                        // too early, always skip
    (minsLeft > MINUTES_LEFT && minsLeft <= 5 && absZ < Z_HUGE) || // 3–5m, only trade if |z| >= Z_HUGE
    (minsLeft <= MINUTES_LEFT && absZ < Z_MIN_LATE)        // ≤3m, require at least Z_MIN_LATE
  ) {
    return null;
  }

  const directionalZMin = minsLeft > MINUTES_LEFT ? Z_MIN_EARLY : Z_MIN_LATE;
  let candidates = [];

  if (z >= directionalZMin && upAsk != null) {
    const evBuyUp = pUp - upAsk;
    candidates.push({ side: "UP", ev: evBuyUp, ask: upAsk });
  }

  if (z <= -directionalZMin && downAsk != null) {
    const evBuyDown = pDown - downAsk;
    candidates.push({ side: "DOWN", ev: evBuyDown, ask: downAsk });
  }

  const minEdge = minsLeft > MINUTES_LEFT ? MIN_EDGE_EARLY : MIN_EDGE_LATE;
  candidates = candidates.filter((c) => c.ev > minEdge);

  if (candidates.length === 0) {
    return null;
  }

  const best = candidates.reduce((a, b) => (b.ev > a.ev ? b : a));

  const sideProbBest = best.side === "UP" ? pUp : pDown;
  const bestPrice = best.ask;

  let riskBand = "medium";
  if (sideProbBest >= PROB_MIN_CORE && bestPrice >= PRICE_MIN_CORE) {
    riskBand = "core";
  } else if (sideProbBest <= PROB_MAX_RISKY && bestPrice <= PRICE_MAX_RISKY) {
    riskBand = "risky";
  }

  const size = sizeForTrade(best.ev, minsLeft, { riskBand });

  if (size <= 0) {
    return null;
  }

  return {
    kind: "normal",
    side: best.side,
    size,
    price: Number(best.ask.toFixed(2)),
    ev: best.ev,
    riskBand,
  };
}

// ---------- PURE DECISION FUNCTION (Step B - extreme late) ----------
// Pure version of the EXTREME-SIGNAL BIG BET mode.
// Ignores inventory/caps; just says "this tick would want an extreme bet" or null.
function decideExtremeLate(snapshot) {
  const {
    symbol,
    minsLeft,
    z,
    pUp,
    pDown,
    upAsk,
    downAsk,
  } = snapshot;

  const absZ = Math.abs(z);
  const zMaxDynamic = dynamicZMax(minsLeft);

  // Same entry window as live: only inside late-game region
  if (!(absZ > zMaxDynamic || (minsLeft < 2 && minsLeft > 0.001))) {
    return null;
  }

  const secsLeft = minsLeft * 60;
  const pReq = requiredLateProb(secsLeft);

  let lateSide = null;
  let sideProb = null;
  let sideAsk = null;

  if (pUp >= pReq && z > Z_MIN_LATE && upAsk != null) {
    lateSide = "UP";
    sideProb = pUp;
    sideAsk = upAsk;
  } else if (pDown >= pReq && z < -Z_MIN_LATE && downAsk != null) {
    lateSide = "DOWN";
    sideProb = pDown;
    sideAsk = downAsk;
  }

  if (!lateSide || sideAsk == null) {
    return null;
  }

  const extremeSignal =
    absZ >= Z_HUGE &&
    secsLeft <= LATE_GAME_EXTREME_SECS &&
    sideAsk <= LATE_GAME_MAX_PRICE &&
    (sideProb - sideAsk) >= LATE_GAME_MIN_EV;

  if (!extremeSignal) {
    return null;
  }

  const maxShares = getMaxSharesForMarket(symbol);
  let bigSize = Math.floor(maxShares * LATE_GAME_MAX_FRACTION);
  if (bigSize <= 0) {
    return null;
  }

  const limitPrice = Number(
    Math.min(sideAsk, LATE_GAME_MAX_PRICE).toFixed(2)
  );
  const ev = sideProb - limitPrice;
  if (ev <= 0) {
    return null;
  }

  return {
    kind: "extreme",
    side: lateSide,
    size: bigSize,
    price: limitPrice,
    ev,
    p: sideProb,
    z,
    secsLeft,
  };
}

// ---------- PURE DECISION FUNCTION (Step B - late layers) ----------
// Pure version of late-game layered bids:
// returns an array of intended layer orders (0–4), ignoring caps/inventory.
function decideLateLayers(snapshot) {
  const {
    minsLeft,
    z,
    pUp,
    pDown,
    upAsk,
    downAsk,
  } = snapshot;

  const absZ = Math.abs(z);
  const zMaxDynamic = dynamicZMax(minsLeft);

  if (!(absZ > zMaxDynamic || (minsLeft < 2 && minsLeft > 0.001))) {
    return [];
  }

  const secsLeft = minsLeft * 60;
  const pReq = requiredLateProb(secsLeft);

  let lateSide = null;
  let sideProb = null;
  let sideAsk = null;

  if (pUp >= pReq && z > Z_MIN_LATE && upAsk != null) {
    lateSide = "UP";
    sideProb = pUp;
    sideAsk = upAsk;
  } else if (pDown >= pReq && z < -Z_MIN_LATE && downAsk != null) {
    lateSide = "DOWN";
    sideProb = pDown;
    sideAsk = downAsk;
  }

  if (!lateSide || sideAsk == null) {
    return [];
  }

  const LAYER_OFFSETS = [-0.02, -0.01, 0.0, +0.01];
  const LAYER_MIN_EV = [0.008, 0.006, 0.004, 0.000];

  const orders = [];

  for (let i = 0; i < LAYER_OFFSETS.length; i++) {
    let target = sideAsk + LAYER_OFFSETS[i];
    target = Math.max(0.01, Math.min(target, 0.99));

    const ev = sideProb - target;
    const minEv = LAYER_MIN_EV[i];
    if (ev < minEv) {
      continue;
    }

    let layerRiskBand = "medium";
    if (sideProb >= PROB_MIN_CORE && target >= PRICE_MIN_CORE) {
      layerRiskBand = "core";
    } else if (sideProb <= PROB_MAX_RISKY && target <= PRICE_MAX_RISKY) {
      layerRiskBand = "risky";
    }

    const size = sizeForTrade(ev, minsLeft, {
      minEdgeOverride: 0.0,
      riskBand: layerRiskBand,
    });

    if (size <= 0) {
      continue;
    }

    const limitPrice = Number(target.toFixed(2));

    orders.push({
      kind: "layer",
      layerIndex: i,
      side: lateSide,
      size,
      price: limitPrice,
      ev,
      riskBand: layerRiskBand,
    });
  }

  return orders;
}
